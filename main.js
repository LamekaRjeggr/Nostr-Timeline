/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NostrTimelinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/views/TimelineView.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_TIMELINE = "nostr-timeline-view";
var NostrTimelineView = class extends import_obsidian.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.events = [];
    this.settings = settings;
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "Nostr Timeline";
  }
  async onOpen() {
    this.container = this.containerEl.children[1];
    this.container.empty();
    this.container.addClass("nostr-timeline-container");
    this.timelineEl = this.container.createDiv("timeline-events");
    this.registerEvent(
      this.app.metadataCache.on("changed", async (file) => {
        if (file.path.startsWith("nostr/notes/") && file.extension === "md") {
          await this.loadNostrNotes();
          this.updateTimelineDisplay();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("create", async (file) => {
        if (file.path.startsWith("nostr/notes/") && file.extension === "md") {
          await this.loadNostrNotes();
          this.updateTimelineDisplay();
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("delete", async (file) => {
        if (file.path.startsWith("nostr/notes/") && file.extension === "md") {
          await this.loadNostrNotes();
          this.updateTimelineDisplay();
        }
      })
    );
    await this.loadNostrNotes();
    this.updateTimelineDisplay();
  }
  async loadNostrNotes() {
    var _a;
    const files = this.app.vault.getFiles();
    const nostrNotes = files.filter(
      (file) => file.path.startsWith("nostr/notes/") && file.extension === "md"
    );
    this.events = [];
    for (const file of nostrNotes) {
      const cache = this.app.metadataCache.getFileCache(file);
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.created) {
        const timestamp = cache.frontmatter.created;
        if (typeof timestamp !== "number")
          continue;
        this.events.push({
          id: file.basename,
          content: cache.frontmatter.content || file.basename,
          created_at: timestamp,
          fileName: file.path,
          author: (cache.frontmatter.author || "Unknown").replace(/[\[\]]/g, ""),
          // Remove any brackets
          isNew: false,
          reply_to: cache.frontmatter.reply_to || null
        });
      }
    }
    this.events.sort((a, b) => b.created_at - a.created_at);
  }
  updateTimelineDisplay() {
    this.timelineEl.empty();
    const timelineContainer = this.timelineEl.createDiv("timeline-container");
    this.events.forEach((event) => {
      const eventEl = this.createEventElement(event);
      timelineContainer.appendChild(eventEl);
    });
  }
  createEventElement(event) {
    var _a, _b;
    const eventEl = document.createElement("div");
    eventEl.className = "timeline-event";
    const file = this.app.vault.getAbstractFileByPath(event.fileName);
    if (file instanceof import_obsidian.TFile) {
      const cache = this.app.metadataCache.getFileCache(file);
      if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.root) {
        eventEl.classList.add("has-root");
        const rootLabel = eventEl.createDiv("branch-label root-label");
        rootLabel.setText("Root");
        const rootPreview = eventEl.createDiv("preview-bubble root-preview");
        rootPreview.setText(typeof cache.frontmatter.root === "string" ? cache.frontmatter.root : "Root note");
      }
      if ((_b = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _b.reply_to) {
        eventEl.classList.add("has-replies");
        const replyLabel = eventEl.createDiv("branch-label reply-label");
        replyLabel.setText("reply");
        const replyPreview = eventEl.createDiv("preview-bubble reply-preview");
        replyPreview.setText(cache.frontmatter.reply_to);
      }
    }
    const content = eventEl.createDiv("event-content");
    const header = content.createDiv("event-header");
    const timestamp = header.createDiv("event-timestamp");
    const date = new Date(event.created_at * 1e3);
    const formattedDate = date.toLocaleString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
      hour: "numeric",
      minute: "2-digit",
      hour12: true
    }).replace(",", " at");
    timestamp.setText(formattedDate);
    const author = header.createEl("a", {
      cls: "event-author",
      text: event.author,
      href: `nostr/profiles/${event.author}.md`
    });
    author.addEventListener("click", (e) => {
      e.stopPropagation();
      this.app.workspace.openLinkText(`nostr/profiles/${event.author}.md`, "", true);
    });
    const noteTitle = content.createDiv("note-title");
    noteTitle.setText(event.id);
    content.addEventListener("click", () => {
      this.app.workspace.openLinkText(event.fileName, "", false);
    });
    return eventEl;
  }
  async refresh() {
    await this.loadNostrNotes();
    this.updateTimelineDisplay();
  }
};

// src/settings/SettingsTab.ts
var import_obsidian2 = require("obsidian");
var NostrTimelineSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Nostr Timeline Settings" });
    new import_obsidian2.Setting(containerEl).setName("Default Time Scale").setDesc("Set the default time scale for the timeline view").addSlider((slider) => slider.setLimits(0.5, 5, 0.5).setValue(this.plugin.settings.scale).onChange(async (value) => {
      this.plugin.settings.scale = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show Timestamps").setDesc("Show timestamps on timeline events by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTimestamps).onChange(async (value) => {
      this.plugin.settings.showTimestamps = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Compact View").setDesc("Use compact view by default").addToggle((toggle) => toggle.setValue(this.plugin.settings.compactView).onChange(async (value) => {
      this.plugin.settings.compactView = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Auto Refresh").setDesc("Automatically refresh timeline when new events arrive").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRefresh).onChange(async (value) => {
      this.plugin.settings.autoRefresh = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  scale: 2,
  // Start with 'Relaxed' view
  filterText: "",
  showTimestamps: true,
  compactView: true,
  // Start with compact view for better readability
  autoRefresh: true
};

// src/main.ts
var NostrTimelinePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_TIMELINE,
      (leaf) => {
        this.view = new NostrTimelineView(leaf, this.settings);
        return this.view;
      }
    );
    this.addRibbonIcon("clock", "Nostr Timeline", () => {
      this.activateView();
    });
    this.addSettingTab(new NostrTimelineSettingTab(this.app, this));
    this.addCommand({
      id: "open-nostr-timeline",
      name: "Open Nostr Timeline",
      callback: () => {
        this.activateView();
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    const existingLeaf = workspace.getLeavesOfType(VIEW_TYPE_TIMELINE)[0];
    if (existingLeaf) {
      workspace.revealLeaf(existingLeaf);
      return;
    }
    const newLeaf = workspace.getRightLeaf(false);
    if (!newLeaf)
      return;
    await newLeaf.setViewState({
      type: VIEW_TYPE_TIMELINE,
      active: true
    });
    workspace.revealLeaf(newLeaf);
  }
  // Method to refresh the timeline
  async refreshTimeline() {
    if (this.view) {
      await this.view.refresh();
    }
  }
};
